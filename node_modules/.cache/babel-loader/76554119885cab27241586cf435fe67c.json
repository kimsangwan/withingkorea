{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"react\"), require(\"react-dom\"));else if (typeof define === 'function' && define.amd) define([\"react\", \"react-dom\"], factory);else if (typeof exports === 'object') exports[\"ReactDraggable\"] = factory(require(\"react\"), require(\"react-dom\"));else root[\"ReactDraggable\"] = factory(root[\"React\"], root[\"ReactDOM\"]);\n})(window, function (__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 4);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       */\n      if (false) {\n        var throwOnDirectAccess, ReactIs;\n      } else {\n        // By explicitly using `prop-types` you are opting into new production behavior.\n        // http://fb.me/prop-types-in-prod\n        module.exports = __webpack_require__(5)();\n      }\n      /***/\n\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE__1__;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE__2__;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n      /*!\n      Copyright (c) 2017 Jed Watson.\n      Licensed under the MIT License (MIT), see\n      http://jedwatson.github.io/classnames\n      */\n\n      /* global define */\n\n\n      (function () {\n        'use strict';\n\n        var hasOwn = {}.hasOwnProperty;\n\n        function classNames() {\n          var classes = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            var arg = arguments[i];\n            if (!arg) continue;\n            var argType = typeof arg;\n\n            if (argType === 'string' || argType === 'number') {\n              classes.push(arg);\n            } else if (Array.isArray(arg) && arg.length) {\n              var inner = classNames.apply(null, arg);\n\n              if (inner) {\n                classes.push(inner);\n              }\n            } else if (argType === 'object') {\n              for (var key in arg) {\n                if (hasOwn.call(arg, key) && arg[key]) {\n                  classes.push(key);\n                }\n              }\n            }\n          }\n\n          return classes.join(' ');\n        }\n\n        if (true && module.exports) {\n          classNames.default = classNames;\n          module.exports = classNames;\n        } else if (true) {\n          // register as 'classnames', consistent with npm package name\n          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return classNames;\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else {}\n      })();\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var _require = __webpack_require__(7),\n          Draggable = _require.default,\n          DraggableCore = _require.DraggableCore; // Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n      // See https://github.com/mzabriskie/react-draggable/pull/254\n      // and https://github.com/mzabriskie/react-draggable/issues/266\n\n\n      module.exports = Draggable;\n      module.exports.default = Draggable;\n      module.exports.DraggableCore = DraggableCore;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       */\n\n      var ReactPropTypesSecret = __webpack_require__(6);\n\n      function emptyFunction() {}\n\n      function emptyFunctionWithReset() {}\n\n      emptyFunctionWithReset.resetWarningCache = emptyFunction;\n\n      module.exports = function () {\n        function shim(props, propName, componentName, location, propFullName, secret) {\n          if (secret === ReactPropTypesSecret) {\n            // It is still safe when called from React.\n            return;\n          }\n\n          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n          err.name = 'Invariant Violation';\n          throw err;\n        }\n\n        ;\n        shim.isRequired = shim;\n\n        function getShim() {\n          return shim;\n        }\n\n        ; // Important!\n        // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n        var ReactPropTypes = {\n          array: shim,\n          bool: shim,\n          func: shim,\n          number: shim,\n          object: shim,\n          string: shim,\n          symbol: shim,\n          any: shim,\n          arrayOf: getShim,\n          element: shim,\n          elementType: shim,\n          instanceOf: getShim,\n          node: shim,\n          objectOf: getShim,\n          oneOf: getShim,\n          oneOfType: getShim,\n          shape: getShim,\n          exact: getShim,\n          checkPropTypes: emptyFunctionWithReset,\n          resetWarningCache: emptyFunction\n        };\n        ReactPropTypes.PropTypes = ReactPropTypes;\n        return ReactPropTypes;\n      };\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /**\n       * Copyright (c) 2013-present, Facebook, Inc.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       */\n\n      var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n      module.exports = ReactPropTypesSecret;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, __webpack_exports__, __webpack_require__) {\n      \"use strict\"; // ESM COMPAT FLAG\n\n      __webpack_require__.r(__webpack_exports__); // EXPORTS\n\n\n      __webpack_require__.d(__webpack_exports__, \"default\", function () {\n        return (\n          /* binding */\n          Draggable_Draggable\n        );\n      });\n\n      __webpack_require__.d(__webpack_exports__, \"DraggableCore\", function () {\n        return (\n          /* reexport */\n          DraggableCore_DraggableCore\n        );\n      }); // EXTERNAL MODULE: external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}\n\n\n      var external_commonjs_react_commonjs2_react_amd_react_root_React_ = __webpack_require__(1); // EXTERNAL MODULE: ./node_modules/prop-types/index.js\n\n\n      var prop_types = __webpack_require__(0);\n\n      var prop_types_default =\n      /*#__PURE__*/\n      __webpack_require__.n(prop_types); // EXTERNAL MODULE: external {\"commonjs\":\"react-dom\",\"commonjs2\":\"react-dom\",\"amd\":\"react-dom\",\"root\":\"ReactDOM\"}\n\n\n      var external_commonjs_react_dom_commonjs2_react_dom_amd_react_dom_root_ReactDOM_ = __webpack_require__(2);\n\n      var external_commonjs_react_dom_commonjs2_react_dom_amd_react_dom_root_ReactDOM_default =\n      /*#__PURE__*/\n      __webpack_require__.n(external_commonjs_react_dom_commonjs2_react_dom_amd_react_dom_root_ReactDOM_); // EXTERNAL MODULE: ./node_modules/classnames/index.js\n\n\n      var classnames = __webpack_require__(3);\n\n      var classnames_default =\n      /*#__PURE__*/\n      __webpack_require__.n(classnames); // CONCATENATED MODULE: ./lib/utils/shims.js\n      // @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\n\n\n      function findInArray(array\n      /*: Array<any> | TouchList*/\n      , callback\n      /*: Function*/\n      )\n      /*: any*/\n      {\n        for (var i = 0, length = array.length; i < length; i++) {\n          if (callback.apply(callback, [array[i], i, array])) return array[i];\n        }\n      }\n\n      function isFunction(func\n      /*: any*/\n      )\n      /*: boolean %checks*/\n      {\n        return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n      }\n\n      function isNum(num\n      /*: any*/\n      )\n      /*: boolean %checks*/\n      {\n        return typeof num === 'number' && !isNaN(num);\n      }\n\n      function shims_int(a\n      /*: string*/\n      )\n      /*: number*/\n      {\n        return parseInt(a, 10);\n      }\n\n      function dontSetMe(props\n      /*: Object*/\n      , propName\n      /*: string*/\n      , componentName\n      /*: string*/\n      ) {\n        if (props[propName]) {\n          return new Error(\"Invalid prop \".concat(propName, \" passed to \").concat(componentName, \" - do not set this, set it on the child.\"));\n        }\n      } // CONCATENATED MODULE: ./lib/utils/getPrefix.js\n\n\n      var prefixes = ['Moz', 'Webkit', 'O', 'ms'];\n\n      function getPrefix()\n      /*: string*/\n      {\n        var prop\n        /*: string*/\n        = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform'; // Checking specifically for 'window.document' is for pseudo-browser server-side\n        // environments that define 'window' as the global context.\n        // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)\n\n        if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';\n        var style = window.document.documentElement.style;\n        if (prop in style) return '';\n\n        for (var i = 0; i < prefixes.length; i++) {\n          if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n        }\n\n        return '';\n      }\n\n      function browserPrefixToKey(prop\n      /*: string*/\n      , prefix\n      /*: string*/\n      )\n      /*: string*/\n      {\n        return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n      }\n\n      function browserPrefixToStyle(prop\n      /*: string*/\n      , prefix\n      /*: string*/\n      )\n      /*: string*/\n      {\n        return prefix ? \"-\".concat(prefix.toLowerCase(), \"-\").concat(prop) : prop;\n      }\n\n      function kebabToTitleCase(str\n      /*: string*/\n      )\n      /*: string*/\n      {\n        var out = '';\n        var shouldCapitalize = true;\n\n        for (var i = 0; i < str.length; i++) {\n          if (shouldCapitalize) {\n            out += str[i].toUpperCase();\n            shouldCapitalize = false;\n          } else if (str[i] === '-') {\n            shouldCapitalize = true;\n          } else {\n            out += str[i];\n          }\n        }\n\n        return out;\n      } // Default export is the prefix itself, like 'Moz', 'Webkit', etc\n      // Note that you may have to re-test for certain things; for instance, Chrome 50\n      // can handle unprefixed `transform`, but not unprefixed `user-select`\n\n      /* harmony default export */\n\n\n      var utils_getPrefix = getPrefix(); // CONCATENATED MODULE: ./lib/utils/domFns.js\n\n      function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n          var symbols = Object.getOwnPropertySymbols(object);\n          if (enumerableOnly) symbols = symbols.filter(function (sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n          keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n      }\n\n      function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n\n          if (i % 2) {\n            ownKeys(Object(source), true).forEach(function (key) {\n              _defineProperty(target, key, source[key]);\n            });\n          } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n          } else {\n            ownKeys(Object(source)).forEach(function (key) {\n              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n          }\n        }\n\n        return target;\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n      /*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/\n\n\n      var matchesSelectorFunc = '';\n\n      function matchesSelector(el\n      /*: Node*/\n      , selector\n      /*: string*/\n      )\n      /*: boolean*/\n      {\n        if (!matchesSelectorFunc) {\n          matchesSelectorFunc = findInArray(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {\n            // $FlowIgnore: Doesn't think elements are indexable\n            return isFunction(el[method]);\n          });\n        } // Might not be found entirely (not an Element?) - in that case, bail\n        // $FlowIgnore: Doesn't think elements are indexable\n\n\n        if (!isFunction(el[matchesSelectorFunc])) return false; // $FlowIgnore: Doesn't think elements are indexable\n\n        return el[matchesSelectorFunc](selector);\n      } // Works up the tree to the draggable itself attempting to match selector.\n\n\n      function matchesSelectorAndParentsTo(el\n      /*: Node*/\n      , selector\n      /*: string*/\n      , baseNode\n      /*: Node*/\n      )\n      /*: boolean*/\n      {\n        var node = el;\n\n        do {\n          if (matchesSelector(node, selector)) return true;\n          if (node === baseNode) return false;\n          node = node.parentNode;\n        } while (node);\n\n        return false;\n      }\n\n      function addEvent(el\n      /*: ?Node*/\n      , event\n      /*: string*/\n      , handler\n      /*: Function*/\n      , inputOptions\n      /*: Object*/\n      )\n      /*: void*/\n      {\n        if (!el) return;\n\n        var options = _objectSpread({\n          capture: true\n        }, inputOptions);\n\n        if (el.addEventListener) {\n          el.addEventListener(event, handler, options);\n        } else if (el.attachEvent) {\n          el.attachEvent('on' + event, handler);\n        } else {\n          // $FlowIgnore: Doesn't think elements are indexable\n          el['on' + event] = handler;\n        }\n      }\n\n      function removeEvent(el\n      /*: ?Node*/\n      , event\n      /*: string*/\n      , handler\n      /*: Function*/\n      , inputOptions\n      /*: Object*/\n      )\n      /*: void*/\n      {\n        if (!el) return;\n\n        var options = _objectSpread({\n          capture: true\n        }, inputOptions);\n\n        if (el.removeEventListener) {\n          el.removeEventListener(event, handler, options);\n        } else if (el.detachEvent) {\n          el.detachEvent('on' + event, handler);\n        } else {\n          // $FlowIgnore: Doesn't think elements are indexable\n          el['on' + event] = null;\n        }\n      }\n\n      function domFns_outerHeight(node\n      /*: HTMLElement*/\n      )\n      /*: number*/\n      {\n        // This is deliberately excluding margin for our calculations, since we are using\n        // offsetTop which is including margin. See getBoundPosition\n        var height = node.clientHeight;\n        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n        height += shims_int(computedStyle.borderTopWidth);\n        height += shims_int(computedStyle.borderBottomWidth);\n        return height;\n      }\n\n      function domFns_outerWidth(node\n      /*: HTMLElement*/\n      )\n      /*: number*/\n      {\n        // This is deliberately excluding margin for our calculations, since we are using\n        // offsetLeft which is including margin. See getBoundPosition\n        var width = node.clientWidth;\n        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n        width += shims_int(computedStyle.borderLeftWidth);\n        width += shims_int(computedStyle.borderRightWidth);\n        return width;\n      }\n\n      function domFns_innerHeight(node\n      /*: HTMLElement*/\n      )\n      /*: number*/\n      {\n        var height = node.clientHeight;\n        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n        height -= shims_int(computedStyle.paddingTop);\n        height -= shims_int(computedStyle.paddingBottom);\n        return height;\n      }\n\n      function domFns_innerWidth(node\n      /*: HTMLElement*/\n      )\n      /*: number*/\n      {\n        var width = node.clientWidth;\n        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n        width -= shims_int(computedStyle.paddingLeft);\n        width -= shims_int(computedStyle.paddingRight);\n        return width;\n      } // Get from offsetParent\n\n\n      function offsetXYFromParent(evt\n      /*: {clientX: number, clientY: number}*/\n      , offsetParent\n      /*: HTMLElement*/\n      , scale\n      /*: number*/\n      )\n      /*: ControlPosition*/\n      {\n        var isBody = offsetParent === offsetParent.ownerDocument.body;\n        var offsetParentRect = isBody ? {\n          left: 0,\n          top: 0\n        } : offsetParent.getBoundingClientRect();\n        var x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n        var y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n        return {\n          x: x,\n          y: y\n        };\n      }\n\n      function createCSSTransform(controlPos\n      /*: ControlPosition*/\n      , positionOffset\n      /*: PositionOffsetControlPosition*/\n      )\n      /*: Object*/\n      {\n        var translation = getTranslation(controlPos, positionOffset, 'px');\n        return _defineProperty({}, browserPrefixToKey('transform', utils_getPrefix), translation);\n      }\n\n      function createSVGTransform(controlPos\n      /*: ControlPosition*/\n      , positionOffset\n      /*: PositionOffsetControlPosition*/\n      )\n      /*: string*/\n      {\n        var translation = getTranslation(controlPos, positionOffset, '');\n        return translation;\n      }\n\n      function getTranslation(_ref2, positionOffset\n      /*: PositionOffsetControlPosition*/\n      , unitSuffix\n      /*: string*/\n      )\n      /*: string*/\n      {\n        var x = _ref2.x,\n            y = _ref2.y;\n        var translation = \"translate(\".concat(x).concat(unitSuffix, \",\").concat(y).concat(unitSuffix, \")\");\n\n        if (positionOffset) {\n          var defaultX = \"\".concat(typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);\n          var defaultY = \"\".concat(typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);\n          translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\") + translation;\n        }\n\n        return translation;\n      }\n\n      function getTouch(e\n      /*: MouseTouchEvent*/\n      , identifier\n      /*: number*/\n      )\n      /*: ?{clientX: number, clientY: number}*/\n      {\n        return e.targetTouches && findInArray(e.targetTouches, function (t) {\n          return identifier === t.identifier;\n        }) || e.changedTouches && findInArray(e.changedTouches, function (t) {\n          return identifier === t.identifier;\n        });\n      }\n\n      function getTouchIdentifier(e\n      /*: MouseTouchEvent*/\n      )\n      /*: ?number*/\n      {\n        if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n        if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n      } // User-select Hacks:\n      //\n      // Useful for preventing blue highlights all over everything when dragging.\n      // Note we're passing `document` b/c we could be iframed\n\n\n      function addUserSelectStyles(doc\n      /*: ?Document*/\n      ) {\n        if (!doc) return;\n        var styleEl = doc.getElementById('react-draggable-style-el');\n\n        if (!styleEl) {\n          styleEl = doc.createElement('style');\n          styleEl.type = 'text/css';\n          styleEl.id = 'react-draggable-style-el';\n          styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n';\n          styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\\n';\n          doc.getElementsByTagName('head')[0].appendChild(styleEl);\n        }\n\n        if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');\n      }\n\n      function removeUserSelectStyles(doc\n      /*: ?Document*/\n      ) {\n        if (!doc) return;\n\n        try {\n          if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection'); // $FlowIgnore: IE\n\n          if (doc.selection) {\n            // $FlowIgnore: IE\n            doc.selection.empty();\n          } else {\n            // Remove selection caused by scroll, unless it's a focused input\n            // (we use doc.defaultView in case we're in an iframe)\n            var selection = (doc.defaultView || window).getSelection();\n\n            if (selection && selection.type !== 'Caret') {\n              selection.removeAllRanges();\n            }\n          }\n        } catch (e) {// probably IE\n        }\n      }\n\n      function addClassName(el\n      /*: HTMLElement*/\n      , className\n      /*: string*/\n      ) {\n        if (el.classList) {\n          el.classList.add(className);\n        } else {\n          if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\")))) {\n            el.className += \" \".concat(className);\n          }\n        }\n      }\n\n      function removeClassName(el\n      /*: HTMLElement*/\n      , className\n      /*: string*/\n      ) {\n        if (el.classList) {\n          el.classList.remove(className);\n        } else {\n          el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\"), 'g'), '');\n        }\n      } // CONCATENATED MODULE: ./lib/utils/positionFns.js\n\n      /*:: import type Draggable from '../Draggable';*/\n\n      /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n\n      /*:: import type DraggableCore from '../DraggableCore';*/\n\n\n      function getBoundPosition(draggable\n      /*: Draggable*/\n      , x\n      /*: number*/\n      , y\n      /*: number*/\n      )\n      /*: [number, number]*/\n      {\n        // If no bounds, short-circuit and move on\n        if (!draggable.props.bounds) return [x, y]; // Clone new bounds\n\n        var bounds = draggable.props.bounds;\n        bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n        var node = positionFns_findDOMNode(draggable);\n\n        if (typeof bounds === 'string') {\n          var ownerDocument = node.ownerDocument;\n          var ownerWindow = ownerDocument.defaultView;\n          var boundNode;\n\n          if (bounds === 'parent') {\n            boundNode = node.parentNode;\n          } else {\n            boundNode = ownerDocument.querySelector(bounds);\n          }\n\n          if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n            throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n          }\n\n          var nodeStyle = ownerWindow.getComputedStyle(node);\n          var boundNodeStyle = ownerWindow.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n\n          bounds = {\n            left: -node.offsetLeft + shims_int(boundNodeStyle.paddingLeft) + shims_int(nodeStyle.marginLeft),\n            top: -node.offsetTop + shims_int(boundNodeStyle.paddingTop) + shims_int(nodeStyle.marginTop),\n            right: domFns_innerWidth(boundNode) - domFns_outerWidth(node) - node.offsetLeft + shims_int(boundNodeStyle.paddingRight) - shims_int(nodeStyle.marginRight),\n            bottom: domFns_innerHeight(boundNode) - domFns_outerHeight(node) - node.offsetTop + shims_int(boundNodeStyle.paddingBottom) - shims_int(nodeStyle.marginBottom)\n          };\n        } // Keep x and y below right and bottom limits...\n\n\n        if (isNum(bounds.right)) x = Math.min(x, bounds.right);\n        if (isNum(bounds.bottom)) y = Math.min(y, bounds.bottom); // But above left and top limits.\n\n        if (isNum(bounds.left)) x = Math.max(x, bounds.left);\n        if (isNum(bounds.top)) y = Math.max(y, bounds.top);\n        return [x, y];\n      }\n\n      function snapToGrid(grid\n      /*: [number, number]*/\n      , pendingX\n      /*: number*/\n      , pendingY\n      /*: number*/\n      )\n      /*: [number, number]*/\n      {\n        var x = Math.round(pendingX / grid[0]) * grid[0];\n        var y = Math.round(pendingY / grid[1]) * grid[1];\n        return [x, y];\n      }\n\n      function canDragX(draggable\n      /*: Draggable*/\n      )\n      /*: boolean*/\n      {\n        return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n      }\n\n      function canDragY(draggable\n      /*: Draggable*/\n      )\n      /*: boolean*/\n      {\n        return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n      } // Get {x, y} positions from event.\n\n\n      function getControlPosition(e\n      /*: MouseTouchEvent*/\n      , touchIdentifier\n      /*: ?number*/\n      , draggableCore\n      /*: DraggableCore*/\n      )\n      /*: ?ControlPosition*/\n      {\n        var touchObj = typeof touchIdentifier === 'number' ? getTouch(e, touchIdentifier) : null;\n        if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n\n        var node = positionFns_findDOMNode(draggableCore); // User can provide an offsetParent if desired.\n\n        var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n        return offsetXYFromParent(touchObj || e, offsetParent, draggableCore.props.scale);\n      } // Create an data object exposed by <DraggableCore>'s events\n\n\n      function createCoreData(draggable\n      /*: DraggableCore*/\n      , x\n      /*: number*/\n      , y\n      /*: number*/\n      )\n      /*: DraggableData*/\n      {\n        var state = draggable.state;\n        var isStart = !isNum(state.lastX);\n        var node = positionFns_findDOMNode(draggable);\n\n        if (isStart) {\n          // If this is our first move, use the x and y as last coords.\n          return {\n            node: node,\n            deltaX: 0,\n            deltaY: 0,\n            lastX: x,\n            lastY: y,\n            x: x,\n            y: y\n          };\n        } else {\n          // Otherwise calculate proper values.\n          return {\n            node: node,\n            deltaX: x - state.lastX,\n            deltaY: y - state.lastY,\n            lastX: state.lastX,\n            lastY: state.lastY,\n            x: x,\n            y: y\n          };\n        }\n      } // Create an data exposed by <Draggable>'s events\n\n\n      function createDraggableData(draggable\n      /*: Draggable*/\n      , coreData\n      /*: DraggableData*/\n      )\n      /*: DraggableData*/\n      {\n        var scale = draggable.props.scale;\n        return {\n          node: coreData.node,\n          x: draggable.state.x + coreData.deltaX / scale,\n          y: draggable.state.y + coreData.deltaY / scale,\n          deltaX: coreData.deltaX / scale,\n          deltaY: coreData.deltaY / scale,\n          lastX: draggable.state.x,\n          lastY: draggable.state.y\n        };\n      } // A lot faster than stringify/parse\n\n\n      function cloneBounds(bounds\n      /*: Bounds*/\n      )\n      /*: Bounds*/\n      {\n        return {\n          left: bounds.left,\n          top: bounds.top,\n          right: bounds.right,\n          bottom: bounds.bottom\n        };\n      }\n\n      function positionFns_findDOMNode(draggable\n      /*: Draggable | DraggableCore*/\n      )\n      /*: HTMLElement*/\n      {\n        var node = draggable.findDOMNode();\n\n        if (!node) {\n          throw new Error('<DraggableCore>: Unmounted during event!');\n        } // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n\n\n        return node;\n      } // CONCATENATED MODULE: ./lib/utils/log.js\n\n      /*eslint no-console:0*/\n\n\n      function log() {\n        var _console;\n\n        if (undefined) (_console = console).log.apply(_console, arguments);\n      } // CONCATENATED MODULE: ./lib/DraggableCore.js\n\n\n      function _typeof(obj) {\n        \"@babel/helpers - typeof\";\n\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n      }\n\n      function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n\n      function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(n);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n      }\n\n      function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n\n        for (var i = 0, arr2 = new Array(len); i < len; i++) {\n          arr2[i] = arr[i];\n        }\n\n        return arr2;\n      }\n\n      function _iterableToArrayLimit(arr, i) {\n        if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      function _createSuper(Derived) {\n        return function () {\n          var Super = _getPrototypeOf(Derived),\n              result;\n\n          if (_isNativeReflectConstruct()) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n\n            result = Reflect.construct(Super, arguments, NewTarget);\n          } else {\n            result = Super.apply(this, arguments);\n          }\n\n          return _possibleConstructorReturn(this, result);\n        };\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _isNativeReflectConstruct() {\n        if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === \"function\") return true;\n\n        try {\n          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function DraggableCore_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n      /*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/\n\n      /*:: import type {Element as ReactElement} from 'react';*/\n      // Simple abstraction for dragging events names.\n\n\n      var eventsFor = {\n        touch: {\n          start: 'touchstart',\n          move: 'touchmove',\n          stop: 'touchend'\n        },\n        mouse: {\n          start: 'mousedown',\n          move: 'mousemove',\n          stop: 'mouseup'\n        }\n      }; // Default to mouse events.\n\n      var dragEventFor = eventsFor.mouse;\n      /*:: type DraggableCoreState = {\n        dragging: boolean,\n        lastX: number,\n        lastY: number,\n        touchIdentifier: ?number\n      };*/\n\n      /*:: export type DraggableData = {\n        node: HTMLElement,\n        x: number, y: number,\n        deltaX: number, deltaY: number,\n        lastX: number, lastY: number,\n      };*/\n\n      /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void;*/\n\n      /*:: export type ControlPosition = {x: number, y: number};*/\n\n      /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/\n\n      /*:: export type DraggableCoreProps = {\n        allowAnyClick: boolean,\n        cancel: string,\n        children: ReactElement<any>,\n        disabled: boolean,\n        enableUserSelectHack: boolean,\n        offsetParent: HTMLElement,\n        grid: [number, number],\n        handle: string,\n        nodeRef?: ?React.ElementRef<any>,\n        onStart: DraggableEventHandler,\n        onDrag: DraggableEventHandler,\n        onStop: DraggableEventHandler,\n        onMouseDown: (e: MouseEvent) => void,\n        scale: number,\n      };*/\n      //\n      // Define <DraggableCore>.\n      //\n      // <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n      // work well with libraries that require more control over the element.\n      //\n\n      var DraggableCore_DraggableCore =\n      /*#__PURE__*/\n      function (_React$Component) {\n        _inherits(DraggableCore, _React$Component);\n\n        var _super = _createSuper(DraggableCore);\n\n        function DraggableCore() {\n          var _this;\n\n          _classCallCheck(this, DraggableCore);\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this].concat(args));\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"state\", {\n            dragging: false,\n            // Used while dragging to determine deltas.\n            lastX: NaN,\n            lastY: NaN,\n            touchIdentifier: null\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"mounted\", false);\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"handleDragStart\", function (e) {\n            // Make it possible to attach event handlers on top of this one.\n            _this.props.onMouseDown(e); // Only accept left-clicks.\n\n\n            if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false; // Get nodes. Be sure to grab relative document (could be iframed)\n\n            var thisNode = _this.findDOMNode();\n\n            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n              throw new Error('<DraggableCore> not mounted on DragStart!');\n            }\n\n            var ownerDocument = thisNode.ownerDocument; // Short circuit if handle or cancel prop was provided and selector doesn't match.\n\n            if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !matchesSelectorAndParentsTo(e.target, _this.props.handle, thisNode) || _this.props.cancel && matchesSelectorAndParentsTo(e.target, _this.props.cancel, thisNode)) {\n              return;\n            } // Prevent scrolling on mobile devices, like ipad/iphone.\n            // Important that this is after handle/cancel.\n\n\n            if (e.type === 'touchstart') e.preventDefault(); // Set touch identifier in component state if this is a touch event. This allows us to\n            // distinguish between individual touches on multitouch screens by identifying which\n            // touchpoint was set to this element.\n\n            var touchIdentifier = getTouchIdentifier(e);\n\n            _this.setState({\n              touchIdentifier: touchIdentifier\n            }); // Get the current drag point from the event. This is used as the offset.\n\n\n            var position = getControlPosition(e, touchIdentifier, _assertThisInitialized(_this));\n            if (position == null) return; // not possible but satisfies flow\n\n            var x = position.x,\n                y = position.y; // Create an event object with all the data parents need to make a decision here.\n\n            var coreEvent = createCoreData(_assertThisInitialized(_this), x, y);\n            log('DraggableCore: handleDragStart: %j', coreEvent); // Call event handler. If it returns explicit false, cancel.\n\n            log('calling', _this.props.onStart);\n\n            var shouldUpdate = _this.props.onStart(e, coreEvent);\n\n            if (shouldUpdate === false || _this.mounted === false) return; // Add a style to the body to disable user-select. This prevents text from\n            // being selected all over the page.\n\n            if (_this.props.enableUserSelectHack) addUserSelectStyles(ownerDocument); // Initiate dragging. Set the current x and y as offsets\n            // so we know how much we've moved during the drag. This allows us\n            // to drag elements around even if they have been moved, without issue.\n\n            _this.setState({\n              dragging: true,\n              lastX: x,\n              lastY: y\n            }); // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n            // this element. We use different events depending on whether or not we have detected that this\n            // is a touch-capable device.\n\n\n            addEvent(ownerDocument, dragEventFor.move, _this.handleDrag);\n            addEvent(ownerDocument, dragEventFor.stop, _this.handleDragStop);\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"handleDrag\", function (e) {\n            // Get the current drag point from the event. This is used as the offset.\n            var position = getControlPosition(e, _this.state.touchIdentifier, _assertThisInitialized(_this));\n            if (position == null) return;\n            var x = position.x,\n                y = position.y; // Snap to grid if prop has been provided\n\n            if (Array.isArray(_this.props.grid)) {\n              var deltaX = x - _this.state.lastX,\n                  deltaY = y - _this.state.lastY;\n\n              var _snapToGrid = snapToGrid(_this.props.grid, deltaX, deltaY);\n\n              var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);\n\n              deltaX = _snapToGrid2[0];\n              deltaY = _snapToGrid2[1];\n              if (!deltaX && !deltaY) return; // skip useless drag\n\n              x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;\n            }\n\n            var coreEvent = createCoreData(_assertThisInitialized(_this), x, y);\n            log('DraggableCore: handleDrag: %j', coreEvent); // Call event handler. If it returns explicit false, trigger end.\n\n            var shouldUpdate = _this.props.onDrag(e, coreEvent);\n\n            if (shouldUpdate === false || _this.mounted === false) {\n              try {\n                // $FlowIgnore\n                _this.handleDragStop(new MouseEvent('mouseup'));\n              } catch (err) {\n                // Old browsers\n                var event = document.createEvent('MouseEvents')\n                /*: any*/\n                ; // I see why this insanity was deprecated\n                // $FlowIgnore\n\n                event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n                _this.handleDragStop(event);\n              }\n\n              return;\n            }\n\n            _this.setState({\n              lastX: x,\n              lastY: y\n            });\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"handleDragStop\", function (e) {\n            if (!_this.state.dragging) return;\n            var position = getControlPosition(e, _this.state.touchIdentifier, _assertThisInitialized(_this));\n            if (position == null) return;\n            var x = position.x,\n                y = position.y;\n            var coreEvent = createCoreData(_assertThisInitialized(_this), x, y); // Call event handler\n\n            var shouldContinue = _this.props.onStop(e, coreEvent);\n\n            if (shouldContinue === false || _this.mounted === false) return false;\n\n            var thisNode = _this.findDOMNode();\n\n            if (thisNode) {\n              // Remove user-select hack\n              if (_this.props.enableUserSelectHack) removeUserSelectStyles(thisNode.ownerDocument);\n            }\n\n            log('DraggableCore: handleDragStop: %j', coreEvent); // Reset the el.\n\n            _this.setState({\n              dragging: false,\n              lastX: NaN,\n              lastY: NaN\n            });\n\n            if (thisNode) {\n              // Remove event handlers\n              log('DraggableCore: Removing handlers');\n              removeEvent(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);\n              removeEvent(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);\n            }\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"onMouseDown\", function (e) {\n            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n            return _this.handleDragStart(e);\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"onMouseUp\", function (e) {\n            dragEventFor = eventsFor.mouse;\n            return _this.handleDragStop(e);\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"onTouchStart\", function (e) {\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return _this.handleDragStart(e);\n          });\n          DraggableCore_defineProperty(_assertThisInitialized(_this), \"onTouchEnd\", function (e) {\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return _this.handleDragStop(e);\n          });\n          return _this;\n        }\n\n        _createClass(DraggableCore, [{\n          key: \"componentDidMount\",\n          value: function componentDidMount() {\n            this.mounted = true; // Touch handlers must be added with {passive: false} to be cancelable.\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n\n            var thisNode = this.findDOMNode();\n\n            if (thisNode) {\n              addEvent(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n              });\n            }\n          }\n        }, {\n          key: \"componentWillUnmount\",\n          value: function componentWillUnmount() {\n            this.mounted = false; // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n            // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n\n            var thisNode = this.findDOMNode();\n\n            if (thisNode) {\n              var ownerDocument = thisNode.ownerDocument;\n              removeEvent(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n              removeEvent(ownerDocument, eventsFor.touch.move, this.handleDrag);\n              removeEvent(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n              removeEvent(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n              removeEvent(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n              });\n              if (this.props.enableUserSelectHack) removeUserSelectStyles(ownerDocument);\n            }\n          } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n          // the underlying DOM node ourselves. See the README for more information.\n\n        }, {\n          key: \"findDOMNode\",\n          value: function findDOMNode()\n          /*: ?HTMLElement*/\n          {\n            return this.props.nodeRef ? this.props.nodeRef.current : external_commonjs_react_dom_commonjs2_react_dom_amd_react_dom_root_ReactDOM_default.a.findDOMNode(this);\n          }\n        }, {\n          key: \"render\",\n          value: function render() {\n            // Reuse the child provided\n            // This makes it flexible to use whatever element is wanted (div, ul, etc)\n            return external_commonjs_react_commonjs2_react_amd_react_root_React_[\"cloneElement\"](external_commonjs_react_commonjs2_react_amd_react_root_React_[\"Children\"].only(this.props.children), {\n              // Note: mouseMove handler is attached to document so it will still function\n              // when the user drags quickly and leaves the bounds of the element.\n              onMouseDown: this.onMouseDown,\n              onMouseUp: this.onMouseUp,\n              // onTouchStart is added on `componentDidMount` so they can be added with\n              // {passive: false}, which allows it to cancel. See \n              // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n              onTouchEnd: this.onTouchEnd\n            });\n          }\n        }]);\n\n        return DraggableCore;\n      }(external_commonjs_react_commonjs2_react_amd_react_root_React_[\"Component\"]);\n\n      DraggableCore_defineProperty(DraggableCore_DraggableCore, \"displayName\", 'DraggableCore');\n      DraggableCore_defineProperty(DraggableCore_DraggableCore, \"propTypes\", {\n        /**\n         * `allowAnyClick` allows dragging using any mouse button.\n         * By default, we only accept the left button.\n         *\n         * Defaults to `false`.\n         */\n        allowAnyClick: prop_types_default.a.bool,\n\n        /**\n         * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n         * with the exception of `onMouseDown`, will not fire.\n         */\n        disabled: prop_types_default.a.bool,\n\n        /**\n         * By default, we add 'user-select:none' attributes to the document body\n         * to prevent ugly text selection during drag. If this is causing problems\n         * for your app, set this to `false`.\n         */\n        enableUserSelectHack: prop_types_default.a.bool,\n\n        /**\n         * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n         * instead of using the parent node.\n         */\n        offsetParent: function offsetParent(props\n        /*: DraggableCoreProps*/\n        , propName\n        /*: $Keys<DraggableCoreProps>*/\n        ) {\n          if (props[propName] && props[propName].nodeType !== 1) {\n            throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n          }\n        },\n\n        /**\n         * `grid` specifies the x and y that dragging should snap to.\n         */\n        grid: prop_types_default.a.arrayOf(prop_types_default.a.number),\n\n        /**\n         * `handle` specifies a selector to be used as the handle that initiates drag.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *         return (\n         *            <Draggable handle=\".handle\">\n         *              <div>\n         *                  <div className=\"handle\">Click me to drag</div>\n         *                  <div>This is some other content</div>\n         *              </div>\n         *           </Draggable>\n         *         );\n         *       }\n         *   });\n         * ```\n         */\n        handle: prop_types_default.a.string,\n\n        /**\n         * `cancel` specifies a selector to be used to prevent drag initialization.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *           return(\n         *               <Draggable cancel=\".cancel\">\n         *                   <div>\n         *                     <div className=\"cancel\">You can't drag from here</div>\n         *                     <div>Dragging here works fine</div>\n         *                   </div>\n         *               </Draggable>\n         *           );\n         *       }\n         *   });\n         * ```\n         */\n        cancel: prop_types_default.a.string,\n\n        /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n         * Unfortunately, in order for <Draggable> to work properly, we need raw access\n         * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n         * as in this example:\n         *\n         * function MyComponent() {\n         *   const nodeRef = React.useRef(null);\n         *   return (\n         *     <Draggable nodeRef={nodeRef}>\n         *       <div ref={nodeRef}>Example Target</div>\n         *     </Draggable>\n         *   );\n         * }\n         *\n         * This can be used for arbitrarily nested components, so long as the ref ends up\n         * pointing to the actual child DOM node and not a custom component.\n         */\n        nodeRef: prop_types_default.a.object,\n\n        /**\n         * Called when dragging starts.\n         * If this function returns the boolean false, dragging will be canceled.\n         */\n        onStart: prop_types_default.a.func,\n\n        /**\n         * Called while dragging.\n         * If this function returns the boolean false, dragging will be canceled.\n         */\n        onDrag: prop_types_default.a.func,\n\n        /**\n         * Called when dragging stops.\n         * If this function returns the boolean false, the drag will remain active.\n         */\n        onStop: prop_types_default.a.func,\n\n        /**\n         * A workaround option which can be passed if onMouseDown needs to be accessed,\n         * since it'll always be blocked (as there is internal use of onMouseDown)\n         */\n        onMouseDown: prop_types_default.a.func,\n\n        /**\n         * `scale`, if set, applies scaling while dragging an element\n         */\n        scale: prop_types_default.a.number,\n\n        /**\n         * These properties should be defined on the child, not here.\n         */\n        className: dontSetMe,\n        style: dontSetMe,\n        transform: dontSetMe\n      });\n      DraggableCore_defineProperty(DraggableCore_DraggableCore, \"defaultProps\", {\n        allowAnyClick: false,\n        // by default only accept left click\n        cancel: null,\n        disabled: false,\n        enableUserSelectHack: true,\n        offsetParent: null,\n        handle: null,\n        grid: null,\n        transform: null,\n        onStart: function onStart() {},\n        onDrag: function onDrag() {},\n        onStop: function onStop() {},\n        onMouseDown: function onMouseDown() {},\n        scale: 1\n      }); // CONCATENATED MODULE: ./lib/Draggable.js\n\n      function Draggable_typeof(obj) {\n        \"@babel/helpers - typeof\";\n\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          Draggable_typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          Draggable_typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return Draggable_typeof(obj);\n      }\n\n      function _extends() {\n        _extends = Object.assign || function (target) {\n          for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            for (var key in source) {\n              if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n              }\n            }\n          }\n\n          return target;\n        };\n\n        return _extends.apply(this, arguments);\n      }\n\n      function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n\n        var target = _objectWithoutPropertiesLoose(source, excluded);\n\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n          for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      function Draggable_slicedToArray(arr, i) {\n        return Draggable_arrayWithHoles(arr) || Draggable_iterableToArrayLimit(arr, i) || Draggable_unsupportedIterableToArray(arr, i) || Draggable_nonIterableRest();\n      }\n\n      function Draggable_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n\n      function Draggable_unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return Draggable_arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(n);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Draggable_arrayLikeToArray(o, minLen);\n      }\n\n      function Draggable_arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n\n        for (var i = 0, arr2 = new Array(len); i < len; i++) {\n          arr2[i] = arr[i];\n        }\n\n        return arr2;\n      }\n\n      function Draggable_iterableToArrayLimit(arr, i) {\n        if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function Draggable_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n\n      function Draggable_ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n          var symbols = Object.getOwnPropertySymbols(object);\n          if (enumerableOnly) symbols = symbols.filter(function (sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n          keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n      }\n\n      function Draggable_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n\n          if (i % 2) {\n            Draggable_ownKeys(Object(source), true).forEach(function (key) {\n              Draggable_defineProperty(target, key, source[key]);\n            });\n          } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n          } else {\n            Draggable_ownKeys(Object(source)).forEach(function (key) {\n              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n          }\n        }\n\n        return target;\n      }\n\n      function Draggable_classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function Draggable_defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function Draggable_createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) Draggable_defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) Draggable_defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function Draggable_inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Draggable_setPrototypeOf(subClass, superClass);\n      }\n\n      function Draggable_setPrototypeOf(o, p) {\n        Draggable_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return Draggable_setPrototypeOf(o, p);\n      }\n\n      function Draggable_createSuper(Derived) {\n        return function () {\n          var Super = Draggable_getPrototypeOf(Derived),\n              result;\n\n          if (Draggable_isNativeReflectConstruct()) {\n            var NewTarget = Draggable_getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n          } else {\n            result = Super.apply(this, arguments);\n          }\n\n          return Draggable_possibleConstructorReturn(this, result);\n        };\n      }\n\n      function Draggable_possibleConstructorReturn(self, call) {\n        if (call && (Draggable_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return Draggable_assertThisInitialized(self);\n      }\n\n      function Draggable_assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function Draggable_isNativeReflectConstruct() {\n        if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === \"function\") return true;\n\n        try {\n          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      function Draggable_getPrototypeOf(o) {\n        Draggable_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return Draggable_getPrototypeOf(o);\n      }\n\n      function Draggable_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n      /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps} from './DraggableCore';*/\n\n      /*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/\n\n      /*:: import type {Element as ReactElement} from 'react';*/\n\n      /*:: type DraggableState = {\n        dragging: boolean,\n        dragged: boolean,\n        x: number, y: number,\n        slackX: number, slackY: number,\n        isElementSVG: boolean,\n        prevPropsPosition: ?ControlPosition,\n      };*/\n\n      /*:: export type DraggableProps = {\n        ...$Exact<DraggableCoreProps>,\n        axis: 'both' | 'x' | 'y' | 'none',\n        bounds: Bounds | string | false,\n        defaultClassName: string,\n        defaultClassNameDragging: string,\n        defaultClassNameDragged: string,\n        defaultPosition: ControlPosition,\n        nodeRef?: ?React.ElementRef<any>,\n        positionOffset: PositionOffsetControlPosition,\n        position: ControlPosition,\n        scale: number\n      };*/\n      //\n      // Define <Draggable>\n      //\n\n\n      var Draggable_Draggable =\n      /*#__PURE__*/\n      function (_React$Component) {\n        Draggable_inherits(Draggable, _React$Component);\n\n        var _super = Draggable_createSuper(Draggable);\n\n        Draggable_createClass(Draggable, null, [{\n          key: \"getDerivedStateFromProps\",\n          // React 16.3+\n          // Arity (props, state)\n          value: function getDerivedStateFromProps(_ref, _ref2) {\n            var position = _ref.position;\n            var prevPropsPosition = _ref2.prevPropsPosition; // Set x/y if a new position is provided in props that is different than the previous.\n\n            if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n              log('Draggable: getDerivedStateFromProps %j', {\n                position: position,\n                prevPropsPosition: prevPropsPosition\n              });\n              return {\n                x: position.x,\n                y: position.y,\n                prevPropsPosition: Draggable_objectSpread({}, position)\n              };\n            }\n\n            return null;\n          }\n        }]);\n\n        function Draggable(props\n        /*: DraggableProps*/\n        ) {\n          var _this;\n\n          Draggable_classCallCheck(this, Draggable);\n          _this = _super.call(this, props);\n          Draggable_defineProperty(Draggable_assertThisInitialized(_this), \"onDragStart\", function (e, coreData) {\n            log('Draggable: onDragStart: %j', coreData); // Short-circuit if user's callback killed it.\n\n            var shouldStart = _this.props.onStart(e, createDraggableData(Draggable_assertThisInitialized(_this), coreData)); // Kills start event on core as well, so move handlers are never bound.\n\n\n            if (shouldStart === false) return false;\n\n            _this.setState({\n              dragging: true,\n              dragged: true\n            });\n          });\n          Draggable_defineProperty(Draggable_assertThisInitialized(_this), \"onDrag\", function (e, coreData) {\n            if (!_this.state.dragging) return false;\n            log('Draggable: onDrag: %j', coreData);\n            var uiData = createDraggableData(Draggable_assertThisInitialized(_this), coreData);\n            var newState\n            /*: $Shape<DraggableState>*/\n            = {\n              x: uiData.x,\n              y: uiData.y\n            }; // Keep within bounds.\n\n            if (_this.props.bounds) {\n              // Save original x and y.\n              var x = newState.x,\n                  y = newState.y; // Add slack to the values used to calculate bound position. This will ensure that if\n              // we start removing slack, the element won't react to it right away until it's been\n              // completely removed.\n\n              newState.x += _this.state.slackX;\n              newState.y += _this.state.slackY; // Get bound position. This will ceil/floor the x and y within the boundaries.\n\n              var _getBoundPosition = getBoundPosition(Draggable_assertThisInitialized(_this), newState.x, newState.y),\n                  _getBoundPosition2 = Draggable_slicedToArray(_getBoundPosition, 2),\n                  newStateX = _getBoundPosition2[0],\n                  newStateY = _getBoundPosition2[1];\n\n              newState.x = newStateX;\n              newState.y = newStateY; // Recalculate slack by noting how much was shaved by the boundPosition handler.\n\n              newState.slackX = _this.state.slackX + (x - newState.x);\n              newState.slackY = _this.state.slackY + (y - newState.y); // Update the event we fire to reflect what really happened after bounds took effect.\n\n              uiData.x = newState.x;\n              uiData.y = newState.y;\n              uiData.deltaX = newState.x - _this.state.x;\n              uiData.deltaY = newState.y - _this.state.y;\n            } // Short-circuit if user's callback killed it.\n\n\n            var shouldUpdate = _this.props.onDrag(e, uiData);\n\n            if (shouldUpdate === false) return false;\n\n            _this.setState(newState);\n          });\n          Draggable_defineProperty(Draggable_assertThisInitialized(_this), \"onDragStop\", function (e, coreData) {\n            if (!_this.state.dragging) return false; // Short-circuit if user's callback killed it.\n\n            var shouldContinue = _this.props.onStop(e, createDraggableData(Draggable_assertThisInitialized(_this), coreData));\n\n            if (shouldContinue === false) return false;\n            log('Draggable: onDragStop: %j', coreData);\n            var newState\n            /*: $Shape<DraggableState>*/\n            = {\n              dragging: false,\n              slackX: 0,\n              slackY: 0\n            }; // If this is a controlled component, the result of this operation will be to\n            // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n\n            var controlled = Boolean(_this.props.position);\n\n            if (controlled) {\n              var _this$props$position = _this.props.position,\n                  x = _this$props$position.x,\n                  y = _this$props$position.y;\n              newState.x = x;\n              newState.y = y;\n            }\n\n            _this.setState(newState);\n          });\n          _this.state = {\n            // Whether or not we are currently dragging.\n            dragging: false,\n            // Whether or not we have been dragged before.\n            dragged: false,\n            // Current transform x and y.\n            x: props.position ? props.position.x : props.defaultPosition.x,\n            y: props.position ? props.position.y : props.defaultPosition.y,\n            prevPropsPosition: Draggable_objectSpread({}, props.position),\n            // Used for compensating for out-of-bounds drags\n            slackX: 0,\n            slackY: 0,\n            // Can only determine if SVG after mounting\n            isElementSVG: false\n          };\n\n          if (props.position && !(props.onDrag || props.onStop)) {\n            // eslint-disable-next-line no-console\n            console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');\n          }\n\n          return _this;\n        }\n\n        Draggable_createClass(Draggable, [{\n          key: \"componentDidMount\",\n          value: function componentDidMount() {\n            // Check to see if the element passed is an instanceof SVGElement\n            if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {\n              this.setState({\n                isElementSVG: true\n              });\n            }\n          }\n        }, {\n          key: \"componentWillUnmount\",\n          value: function componentWillUnmount() {\n            this.setState({\n              dragging: false\n            }); // prevents invariant if unmounted while dragging\n          } // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n          // the underlying DOM node ourselves. See the README for more information.\n\n        }, {\n          key: \"findDOMNode\",\n          value: function findDOMNode()\n          /*: ?HTMLElement*/\n          {\n            return this.props.nodeRef ? this.props.nodeRef.current : external_commonjs_react_dom_commonjs2_react_dom_amd_react_dom_root_ReactDOM_default.a.findDOMNode(this);\n          }\n        }, {\n          key: \"render\",\n          value: function render()\n          /*: ReactElement<any>*/\n          {\n            var _classNames;\n\n            var _this$props = this.props,\n                axis = _this$props.axis,\n                bounds = _this$props.bounds,\n                children = _this$props.children,\n                defaultPosition = _this$props.defaultPosition,\n                defaultClassName = _this$props.defaultClassName,\n                defaultClassNameDragging = _this$props.defaultClassNameDragging,\n                defaultClassNameDragged = _this$props.defaultClassNameDragged,\n                position = _this$props.position,\n                positionOffset = _this$props.positionOffset,\n                scale = _this$props.scale,\n                draggableCoreProps = _objectWithoutProperties(_this$props, [\"axis\", \"bounds\", \"children\", \"defaultPosition\", \"defaultClassName\", \"defaultClassNameDragging\", \"defaultClassNameDragged\", \"position\", \"positionOffset\", \"scale\"]);\n\n            var style = {};\n            var svgTransform = null; // If this is controlled, we don't want to move it - unless it's dragging.\n\n            var controlled = Boolean(position);\n            var draggable = !controlled || this.state.dragging;\n            var validPosition = position || defaultPosition;\n            var transformOpts = {\n              // Set left if horizontal drag is enabled\n              x: canDragX(this) && draggable ? this.state.x : validPosition.x,\n              // Set top if vertical drag is enabled\n              y: canDragY(this) && draggable ? this.state.y : validPosition.y\n            }; // If this element was SVG, we use the `transform` attribute.\n\n            if (this.state.isElementSVG) {\n              svgTransform = createSVGTransform(transformOpts, positionOffset);\n            } else {\n              // Add a CSS transform to move the element around. This allows us to move the element around\n              // without worrying about whether or not it is relatively or absolutely positioned.\n              // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n              // has a clean slate.\n              style = createCSSTransform(transformOpts, positionOffset);\n            } // Mark with class while dragging\n\n\n            var className = classnames_default()(children.props.className || '', defaultClassName, (_classNames = {}, Draggable_defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), Draggable_defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames)); // Reuse the child provided\n            // This makes it flexible to use whatever element is wanted (div, ul, etc)\n\n            return (\n              /*#__PURE__*/\n              external_commonjs_react_commonjs2_react_amd_react_root_React_[\"createElement\"](DraggableCore_DraggableCore, _extends({}, draggableCoreProps, {\n                onStart: this.onDragStart,\n                onDrag: this.onDrag,\n                onStop: this.onDragStop\n              }), external_commonjs_react_commonjs2_react_amd_react_root_React_[\"cloneElement\"](external_commonjs_react_commonjs2_react_amd_react_root_React_[\"Children\"].only(children), {\n                className: className,\n                style: Draggable_objectSpread({}, children.props.style, {}, style),\n                transform: svgTransform\n              }))\n            );\n          }\n        }]);\n        return Draggable;\n      }(external_commonjs_react_commonjs2_react_amd_react_root_React_[\"Component\"]);\n\n      Draggable_defineProperty(Draggable_Draggable, \"displayName\", 'Draggable');\n      Draggable_defineProperty(Draggable_Draggable, \"propTypes\", Draggable_objectSpread({}, DraggableCore_DraggableCore.propTypes, {\n        /**\n         * `axis` determines which axis the draggable can move.\n         *\n         *  Note that all callbacks will still return data as normal. This only\n         *  controls flushing to the DOM.\n         *\n         * 'both' allows movement horizontally and vertically.\n         * 'x' limits movement to horizontal axis.\n         * 'y' limits movement to vertical axis.\n         * 'none' limits all movement.\n         *\n         * Defaults to 'both'.\n         */\n        axis: prop_types_default.a.oneOf(['both', 'x', 'y', 'none']),\n\n        /**\n         * `bounds` determines the range of movement available to the element.\n         * Available values are:\n         *\n         * 'parent' restricts movement within the Draggable's parent node.\n         *\n         * Alternatively, pass an object with the following properties, all of which are optional:\n         *\n         * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n         *\n         * All values are in px.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *         return (\n         *            <Draggable bounds={{right: 300, bottom: 300}}>\n         *              <div>Content</div>\n         *           </Draggable>\n         *         );\n         *       }\n         *   });\n         * ```\n         */\n        bounds: prop_types_default.a.oneOfType([prop_types_default.a.shape({\n          left: prop_types_default.a.number,\n          right: prop_types_default.a.number,\n          top: prop_types_default.a.number,\n          bottom: prop_types_default.a.number\n        }), prop_types_default.a.string, prop_types_default.a.oneOf([false])]),\n        defaultClassName: prop_types_default.a.string,\n        defaultClassNameDragging: prop_types_default.a.string,\n        defaultClassNameDragged: prop_types_default.a.string,\n\n        /**\n         * `defaultPosition` specifies the x and y that the dragged item should start at\n         *\n         * Example:\n         *\n         * ```jsx\n         *      let App = React.createClass({\n         *          render: function () {\n         *              return (\n         *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n         *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n         *                  </Draggable>\n         *              );\n         *          }\n         *      });\n         * ```\n         */\n        defaultPosition: prop_types_default.a.shape({\n          x: prop_types_default.a.number,\n          y: prop_types_default.a.number\n        }),\n        positionOffset: prop_types_default.a.shape({\n          x: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n          y: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])\n        }),\n\n        /**\n         * `position`, if present, defines the current position of the element.\n         *\n         *  This is similar to how form elements in React work - if no `position` is supplied, the component\n         *  is uncontrolled.\n         *\n         * Example:\n         *\n         * ```jsx\n         *      let App = React.createClass({\n         *          render: function () {\n         *              return (\n         *                  <Draggable position={{x: 25, y: 25}}>\n         *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n         *                  </Draggable>\n         *              );\n         *          }\n         *      });\n         * ```\n         */\n        position: prop_types_default.a.shape({\n          x: prop_types_default.a.number,\n          y: prop_types_default.a.number\n        }),\n\n        /**\n         * These properties should be defined on the child, not here.\n         */\n        className: dontSetMe,\n        style: dontSetMe,\n        transform: dontSetMe\n      }));\n      Draggable_defineProperty(Draggable_Draggable, \"defaultProps\", Draggable_objectSpread({}, DraggableCore_DraggableCore.defaultProps, {\n        axis: 'both',\n        bounds: false,\n        defaultClassName: 'react-draggable',\n        defaultClassNameDragging: 'react-draggable-dragging',\n        defaultClassNameDragged: 'react-draggable-dragged',\n        defaultPosition: {\n          x: 0,\n          y: 0\n        },\n        position: null,\n        scale: 1\n      }));\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}